package com.goody.nus.se.gomoku.ranking.service.impl;

import com.goody.nus.se.gomoku.common.util.UidGeneratorUtil;
import com.goody.nus.se.gomoku.ranking.model.dao.RankingDynamicSqlSupport;
import com.goody.nus.se.gomoku.ranking.model.dao.RankingMapper;
import com.goody.nus.se.gomoku.ranking.model.dao.customer.CustomerRankingMapper;
import com.goody.nus.se.gomoku.ranking.model.dto.RankingDTO;
import com.goody.nus.se.gomoku.ranking.model.entity.Ranking;
import com.goody.nus.se.gomoku.ranking.service.interfaces.IRankingService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import static com.goody.nus.se.gomoku.ranking.model.dao.RankingDynamicSqlSupport.currentTotalScore;
import static com.goody.nus.se.gomoku.ranking.model.dao.RankingDynamicSqlSupport.updatedTime;
import static org.mybatis.dynamic.sql.SqlBuilder.isEqualTo;
import static org.mybatis.dynamic.sql.SqlBuilder.isGreaterThan;

/**
 * Service implementation for Ranking
 * Generated by MyBatis Generator Service Plugin
 */
@Service
public class RankingServiceImpl implements IRankingService {
    @Autowired
    private RankingMapper rankingMapper;

    @Autowired
    private CustomerRankingMapper customerRankingMapper;

    @Override
    public Long save(RankingDTO dto) {
        if (dto == null) {
            return null;
        }

        if (dto.getId() == null) {
            dto.setId(UidGeneratorUtil.generateUid());
        }

        Ranking entity = dto.toEntity();
        int result = rankingMapper.insertSelective(entity);
        return result > 0 ? entity.getId() : null;
    }

    @Override
    public int saveBatch(List<RankingDTO> dtoList) {
        if (dtoList == null || dtoList.isEmpty()) {
            return 0;
        }

        List<Ranking> entityList = dtoList.stream()
                .filter(dto -> dto != null)
                .peek(dto -> {
                    if (dto.getId() == null) {
                        dto.setId(UidGeneratorUtil.generateUid());
                    }
                    if (dto.getCreatedTime() == null) {
                        dto.setCreatedTime(LocalDateTime.now());
                    }
                    if (dto.getUpdatedTime() == null) {
                        dto.setUpdatedTime(LocalDateTime.now());
                    }
                })
                .map(RankingDTO::toEntity)
                .collect(Collectors.toList());

        if (entityList.isEmpty()) {
            return 0;
        }

        return rankingMapper.insertMultiple(entityList);
    }

    @Override
    public int update(RankingDTO dto) {
        if (dto == null) {
            return 0;
        }

        Ranking entity = dto.toEntity();
        return rankingMapper.updateByPrimaryKeySelective(entity);
    }

    @Override
    public int deleteById(Long id) {
        if (id == null) {
            return 0;
        }

        return rankingMapper.deleteByPrimaryKey(id);
    }

    @Override
    public RankingDTO findById(Long id) {
        if (id == null) {
            return null;
        }

        Ranking entity = rankingMapper.selectByPrimaryKey(id).orElse(null);
        return entity != null ? RankingDTO.fromEntity(entity) : null;
    }

    @Override
    public List<RankingDTO> findAll() {
        List<Ranking> entityList = rankingMapper.select(c -> c);
        return entityList.stream()
                .map(RankingDTO::fromEntity)
                .collect(Collectors.toList());
    }

    // ==================== Custom Query Methods Implementation ====================

    @Override
    public RankingDTO findByUserIdAndLeaderboardRuleId(Long userId, Long leaderboardRuleId) {
        if (userId == null || leaderboardRuleId == null) {
            return null;
        }
        Ranking entity = rankingMapper.selectOne(c ->
                c.where(RankingDynamicSqlSupport.userId, isEqualTo(userId))
                        .and(RankingDynamicSqlSupport.leaderboardRuleId, isEqualTo(leaderboardRuleId))
                        .limit(1)
        ).orElse(null);
        return entity != null ? RankingDTO.fromEntity(entity) : null;
    }

    @Override
    public List<RankingDTO> findTopByLeaderboardRuleId(Long leaderboardRuleId, int limit) {
        if (leaderboardRuleId == null) {
            return List.of();
        }
        List<Ranking> entityList = rankingMapper.select(c ->
                c.where(RankingDynamicSqlSupport.leaderboardRuleId, isEqualTo(leaderboardRuleId))
                        .orderBy(currentTotalScore.descending(), updatedTime, RankingDynamicSqlSupport.userId)
                        .limit(limit)
        );
        return entityList.stream()
                .map(RankingDTO::fromEntity)
                .collect(Collectors.toList());
    }

    @Override
    public long countByLeaderboardRuleId(Long leaderboardRuleId) {
        if (leaderboardRuleId == null) {
            return 0;
        }
        return rankingMapper.count(c ->
                c.where(RankingDynamicSqlSupport.leaderboardRuleId, isEqualTo(leaderboardRuleId))
        );
    }

    @Override
    public long countByLeaderboardRuleIdAndScoreGreaterThan(Long leaderboardRuleId, int score) {
        if (leaderboardRuleId == null) {
            return 0;
        }
        return rankingMapper.count(c ->
                c.where(RankingDynamicSqlSupport.leaderboardRuleId, isEqualTo(leaderboardRuleId))
                        .and(currentTotalScore, isGreaterThan(score))
        );
    }
}
